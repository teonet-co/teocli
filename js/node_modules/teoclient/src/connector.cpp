/**
 * File:   connector.cpp
 * Author: Alexander Ksenofontov <aksenofo@yahoo.ru>
 *
 * Created on August 3, 2016, 12:32 PM
 */


#include "connector.h"
#include "errno_exeption.h"
#include "teo_exeption.h"
#include "teo_packet.h"
#include <sys/timeb.h>
#include <iostream>

//https://gist.github.com/bellbind/a68620383e0180b3afc6

#define MAKE_THROW_IF_NOT_CONNECTED(METHOS_NAME) \
{\
    auto This(Nan::ObjectWrap::Unwrap<Connector>(info.Holder()));\
    if(!This->is_connected())\
	return Nan::ThrowError(TeoExeption::createNewInstance(METHOS_NAME, "Connection was not been opened."));\
}

#define SET_PROP_STR(OBJ,NAME,VALUE) \
    OBJ->Set(Nan::New<String>(#NAME).ToLocalChecked(), Nan::New<String>(VALUE).ToLocalChecked());
#define SET_PROP_INT(OBJ,NAME,VALUE) \
    OBJ->Set(Nan::New<String>(#NAME).ToLocalChecked(), Nan::New<Integer>(VALUE));
#define SET_PROP_NUMB(OBJ,NAME,VALUE) \
    OBJ->Set(Nan::New<String>(#NAME).ToLocalChecked(), Nan::New<Number>(VALUE));

using namespace Nan;
using namespace v8;

Nan::Persistent<v8::Function> Connector::constructor;

Connector::~Connector() {
    if(connector_) // Do not call free. Use native disconnect
	teoLNullDisconnect(connector_);
    connector_ = nullptr;
}

bool Connector::connect() {
    assert(!connector_);
    connector_ = teoLNullConnect(ip_.c_str(), port_);
    if(connector_ == nullptr || connector_->fd <= 0) {
	if(connector_)
	    teoLNullDisconnect(connector_);
	connector_ = nullptr;
	return false;
    }
    return true;
}

void Connector::disconnect() {
    assert(connector_);
    teoLNullDisconnect(connector_);
    connector_ = nullptr;
}

ssize_t Connector::login(const char* host_name) {
    assert(connector_);
    return teoLNullLogin(connector_, host_name);
}

ssize_t Connector::send(int cmd, const char *peer_name, const void *data, size_t data_length) {
    assert(connector_);
    return teoLNullSend(connector_, cmd, peer_name, (void*)data, data_length);
}

ssize_t Connector::recv() {
    assert(connector_);
    return teoLNullRecv(connector_);
}

/**
 * Login to L0 server
 *.
 * Create and send L0 clients initialization packet
 *.
 * @param con Pointer to teoLNullConnectData
 * @param host_name Client name
 *.
 * @return Length of send data or -1 at error
 */
NAN_METHOD(Connector::Login) {
    Nan::HandleScope scope;
    if(info.Length() < 1 )
	Nan::ThrowError("Not enough parameters");
    MAKE_THROW_IF_NOT_CONNECTED("Connector::login");

    auto This(Nan::ObjectWrap::Unwrap<Connector>(info.Holder()));
    size_t snd(This->login(*Nan::Utf8String(info[0])));
    if(snd == (size_t)-1)
        Nan::ThrowError(TeoErrnoExeption::createNewInstance(errno, "Connector.login()"));
    else
        info.GetReturnValue().Set((int)snd);
}

/**
 * Send command to L0 server
 *.
 * Create L0 clients packet and send it to L0 server
 *.
 * @param cmd Command
 * @param peer_name Peer name to send to
 * @param data Array of data (optioonal)
 *.
 * @return Length of send data or -1 at error
 */
NAN_METHOD(Connector::Send) {
    Nan::HandleScope scope;
    if(info.Length() < 2 )
	Nan::ThrowError("Not enough parameters");
    MAKE_THROW_IF_NOT_CONNECTED("Connector::send");
    auto This(Nan::ObjectWrap::Unwrap<Connector>(info.Holder()));
    auto cmd(info[0]->IntegerValue());
    auto peer_name(*Nan::Utf8String(info[1]));
    const char* buffer = nullptr;
    size_t buffer_len(0);
    if(info.Length() >= 3 ) {
	buffer = *Nan::Utf8String(info[2]);
	buffer_len = Nan::Utf8String(info[2]).length();
    }

    size_t snd(This->send(cmd, peer_name, buffer, buffer_len));

    if(snd == (size_t)-1)
        Nan::ThrowError(TeoErrnoExeption::createNewInstance(errno, "Connector.send()"));
    else
        info.GetReturnValue().Set((int)snd);
}

Local<Value> Connector::fnCMD_L_ECHO_ANSWER(const Nan::FunctionCallbackInfo<v8::Value>& info) {
    if(length() > 1) {
	Local<Object> obj(Object::New(info.GetIsolate()));
	Local<Object> master(Object::New(info.GetIsolate()));
	master->Set(Nan::New<String>("CMD_L_ECHO_ANSWER").ToLocalChecked(), obj);
	return master;
 
    }
    return Undefined();
}

Local<Value> Connector::fnCMD_L_L0_CLIENTS_ANSWER(const Nan::FunctionCallbackInfo<v8::Value>& info) {
    if(length() > 1) {
	const teonet_client_data_ar *client_data_ar(static_cast<const teonet_client_data_ar*>(arp_data()));
	Local<Array> list = Array::New(info.GetIsolate());
	for(int i(0); i < (int)client_data_ar->length; i++) {
	    Local<Object> obj(Object::New(info.GetIsolate()));
	    SET_PROP_STR(obj, name, client_data_ar->client_data[i].name);
	    list->Set(i, obj);
	}
	Local<Object> master(Object::New(info.GetIsolate()));
	master->Set(Nan::New<String>("CMD_L_L0_CLIENTS_ANSWER").ToLocalChecked(), list);
	return master;
    }
    else
	return Undefined();
}

Local<Value> Connector::fnCMD_L_PEERS_ANSWER(const Nan::FunctionCallbackInfo<v8::Value>& info) {
    if(length() > 1) {
	const ksnet_arp_data_ar* arp_data_ar(static_cast<const ksnet_arp_data_ar*>(arp_data()));
	Local<Array> list = Array::New(info.GetIsolate());
	for(size_t i(0); i < (int)arp_data_ar->length; i++) {
	    Local<Object> obj(Object::New(info.GetIsolate()));
	    SET_PROP_STR(obj, name, arp_data_ar->arp_data[i].name);
	    SET_PROP_INT(obj, mode, arp_data_ar->arp_data[i].data.mode);
	    SET_PROP_STR(obj, addr, arp_data_ar->arp_data[i].data.addr);
	    SET_PROP_INT(obj, port, arp_data_ar->arp_data[i].data.port);
	    SET_PROP_NUMB(obj, last_activity, arp_data_ar->arp_data[i].data.last_activity);
	    SET_PROP_NUMB(obj, last_triptime_send, arp_data_ar->arp_data[i].data.last_triptime_send);
	    SET_PROP_NUMB(obj, last_triptime_got, arp_data_ar->arp_data[i].data.last_triptime_got);
	    SET_PROP_NUMB(obj, last_triptime, arp_data_ar->arp_data[i].data.last_triptime);
	    SET_PROP_NUMB(obj, triptime, arp_data_ar->arp_data[i].data.triptime);
	    SET_PROP_NUMB(obj, monitor_time, arp_data_ar->arp_data[i].data.monitor_time);
	    SET_PROP_NUMB(obj, connected_time, arp_data_ar->arp_data[i].data.connected_time);
	    list->Set(i, obj);
	}
	Local<Object> master(Object::New(info.GetIsolate()));
	master->Set(Nan::New<String>("CMD_L_PEERS_ANSWER").ToLocalChecked(), list);
	return master;
    }
    return Undefined();
}

NAN_METHOD(Connector::Disconnect) {
    Nan::HandleScope scope;
    MAKE_THROW_IF_NOT_CONNECTED("Connector::disconnect");
    auto This(Nan::ObjectWrap::Unwrap<Connector>(info.Holder()));
    This->disconnect();
}

NAN_METHOD(Connector::Recv) {

    Nan::HandleScope scope;

    MAKE_THROW_IF_NOT_CONNECTED("Connector::recv");
    auto This(Nan::ObjectWrap::Unwrap<Connector>(info.Holder()));
    ssize_t size(This->recv());
    if(size == -1)
        return (void)Nan::ThrowError(TeoErrnoExeption::createNewInstance(errno, "Connector.recv()"));
    else {
	std::cout << This->cmd() << " " << This->name() << std::endl;
	// Parse type
	switch(This->cmd()) {
	    case CMD_L_ECHO_ANSWER:
		info.GetReturnValue().Set(This->fnCMD_L_ECHO_ANSWER(info));
	    return;
	    case CMD_L_PEERS_ANSWER:
		info.GetReturnValue().Set(This->fnCMD_L_PEERS_ANSWER(info));
	    return;
	    case CMD_L_AUTH_ANSWER:
	    break;
	    case CMD_L_L0_CLIENTS_ANSWER:
		info.GetReturnValue().Set(This->fnCMD_L_L0_CLIENTS_ANSWER(info));
	    return;
	    default:
		break;
	}
        return info.GetReturnValue().Set(Undefined());
    }
}

NAN_METHOD(Connector::Sleep) {
    Nan::HandleScope scope;
    if(info.Length() < 1 )
	Nan::ThrowError("Not enough parameters");
    double seconds (info[0]->NumberValue());
    teoLNullSleep(seconds * 1000.0);
}

NAN_METHOD(Connector::New) {
    Nan::HandleScope scope;

    if (!info.IsConstructCall()) {
	// [NOTE] generic recursive call with `new`
	std::vector<v8::Local<v8::Value>> args(info.Length());
	for (std::size_t i = 0; i < args.size(); ++i) args[i] = info[i];
	auto inst = Nan::NewInstance(info.Callee(), args.size(), args.data());
	if (!inst.IsEmpty()) info.GetReturnValue().Set(inst.ToLocalChecked());
	return;
    }

    if(info.Length() < 2 )
	Nan::ThrowError("Not enough parameters");

    auto object(new Connector(*Nan::Utf8String(info[0]), info[1]->IntegerValue()));

    if(!object->connect()) {
	auto terrno = errno;
	delete object;
	Nan::ThrowError(TeoErrnoExeption::createNewInstance(terrno, "Connector"));
    }
    else {
	object->Wrap(info.This()); // `Wrap` bind C++ object to JS object.
    }
}

NAN_MODULE_INIT(Connector::Init) {
    Nan::HandleScope scope;
    auto cname = Nan::New("Connector").ToLocalChecked();
    auto ctor = Nan::New<v8::FunctionTemplate>(New);
    auto ctorInst = ctor->InstanceTemplate(); // target for member functions
    ctor->SetClassName(cname); // as `ctor.name` in JS
    ctorInst->SetInternalFieldCount(1); // for ObjectWrap, it should set 1

    // add member functions and accessors
    Nan::SetPrototypeMethod(ctor, "login", Login);
    Nan::SetPrototypeMethod(ctor, "send", Send);
    Nan::SetPrototypeMethod(ctor, "recv", Recv);
    Nan::SetPrototypeMethod(ctor, "sleep", Sleep);
    Nan::SetPrototypeMethod(ctor, "disconnect", Disconnect);

    Nan::Set(target, cname, Nan::GetFunction(ctor).ToLocalChecked());

    IMPL_CONSTANT(ctorInst, CMD_L_ECHO);
    IMPL_CONSTANT(ctorInst, CMD_L_ECHO_ANSWER);
    IMPL_CONSTANT(ctorInst, CMD_L_PEERS);
    IMPL_CONSTANT(ctorInst, CMD_L_PEERS_ANSWER);
    IMPL_CONSTANT(ctorInst, CMD_L_AUTH);
    IMPL_CONSTANT(ctorInst, CMD_L_AUTH_ANSWER);
    IMPL_CONSTANT(ctorInst, CMD_L_L0_CLIENTS);
    IMPL_CONSTANT(ctorInst, CMD_L_L0_CLIENTS_ANSWER);
    IMPL_CONSTANT(ctorInst, CMD_L_SUBSCRIBE_ANSWER);
    IMPL_CONSTANT(ctorInst, CMD_L_END);

    constructor.Reset(ctor->GetFunction());
}

v8::Local<v8::Value> Connector::createNewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {

    v8::Local<v8::Value> argv[info.Length()];
    for( auto i(0); i < info.Length(); i++)
	argv[i] = info[i];

    return Nan::New<v8::Function>(constructor)->NewInstance(info.Length(), argv);
}
