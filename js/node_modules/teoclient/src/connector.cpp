/**
 * File:   connector.cpp
 * Author: Alexander Ksenofontov <aksenofo@yahoo.ru>
 *
 * Created on August 3, 2016, 12:32 PM
 */


#include "connector.h"
#include "errno_exeption.h"
#include <iostream>

//https://gist.github.com/bellbind/a68620383e0180b3afc6

using namespace Nan;
using namespace v8;

Nan::Persistent<v8::Function> Connector::constructor;

Connector::~Connector() {
    if(connector_)
	free(connector_);
    connector_ = nullptr;
}

bool Connector::connect() {
    connector_ = teoLNullConnect(ip_.c_str(), port_);
    if(connector_ == nullptr or connector_->fd <= 0)
	return false;
    return true;
}

NAN_METHOD(Connector::Login) {

}

NAN_METHOD(Connector::New) {
    Nan::HandleScope scope;

    if (!info.IsConstructCall()) {
	// [NOTE] generic recursive call with `new`
	std::vector<v8::Local<v8::Value>> args(info.Length());
	for (std::size_t i = 0; i < args.size(); ++i) args[i] = info[i];
	auto inst = Nan::NewInstance(info.Callee(), args.size(), args.data());
	if (!inst.IsEmpty()) info.GetReturnValue().Set(inst.ToLocalChecked());
	return;
    }

    if(info.Length() < 2 )
	Nan::ThrowError("Not enough parameters");

    auto object(new Connector(*Nan::Utf8String(info[0]), info[1]->IntegerValue()));

    if(!object->connect()) {
	auto terrno = errno;
	delete object;
	Nan::ThrowError(TeoErrnoExeption::createNewInstance(terrno, "Connector"));
    }
    else {
	object->Wrap(info.This()); // `Wrap` bind C++ object to JS object.
    }
}

NAN_MODULE_INIT(Connector::Init) {
    Nan::HandleScope scope;
    auto cname = Nan::New("Connector").ToLocalChecked();
    auto ctor = Nan::New<v8::FunctionTemplate>(New);
    auto ctorInst = ctor->InstanceTemplate(); // target for member functions
    ctor->SetClassName(cname); // as `ctor.name` in JS
    ctorInst->SetInternalFieldCount(1); // for ObjectWrap, it should set 1

    // add member functions and accessors
    Nan::SetPrototypeMethod(ctor, "login", Login);
    Nan::Set(target, cname, Nan::GetFunction(ctor).ToLocalChecked());

    constructor.Reset(ctor->GetFunction());
}

v8::Local<v8::Value> Connector::createNewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {

    v8::Local<v8::Value> argv[info.Length()];
    for( auto i(0); i < info.Length(); i++)
	argv[i] = info[i];

    return Nan::New<v8::Function>(constructor)->NewInstance(info.Length(), argv);
}
