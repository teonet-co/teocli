/*
 * Copyright (c) 1996-2015 Kirill Scherba <kirill@scherba.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef TEOCLI_CPP_H
#define	TEOCLI_CPP_H

#include "teonet_l0_client.h"

/**
 * Teocli class.
 * 
 * This is Teonet L0 client C++ wrapper
 */
class Teocli {
    
private:    
    
    teoLNullConnectData *con;

    /**
     * Initialize L0 client library.
     * 
     * Calls once per application to initialize this client library.
     */
    inline void init() { teoLNullInit(); }
    
    /**
     * Cleanup L0 client library.
     * 
     * Calls once per application to cleanup this client library.
     */
    inline void cleanup() { teoLNullCleanup(); }
    

public:

    /**
     * Teonet client simple constructor
     */
    Teocli() { con = NULL; init(); }    
    Teocli(const char *server, int port) : Teocli()  {
        //Teocli();
        connect(server, port);
    }
    
    /**
     * Teonet client simple destructor
     */
    ~Teocli() { cleanup(); }
    
    /**
     * Check if this class is connected to L0 server
     * 
     * @return connected status 
     * @retval 0 if disconnected
     * @retval teoLNullConnectData::fd>0   - Success connection
     * @retval teoLNullConnectData::fd==-1 - Create socket error
     * @retval teoLNullConnectData::fd==-2 - HOST NOT FOUND error
     * @retval teoLNullConnectData::fd==-3 - Client-connect() error 
     */
    inline int connected() {
        return con == NULL ? 0:con->fd;
    }
    
    /**
     * Create TCP client and connect to server
     * 
     * @param server Server IP or name
     * @param port Server port
     * 
     * @return Pointer to teoLNullConnectData. Null if no memory error
     * @retval teoLNullConnectData::fd>0   - Success connection
     * @retval teoLNullConnectData::fd==-1 - Create socket error
     * @retval teoLNullConnectData::fd==-2 - HOST NOT FOUND error
     * @retval teoLNullConnectData::fd==-3 - Client-connect() error
     */
    inline teoLNullConnectData *connect(const char *server, int port) {
        return con = teoLNullConnect(server, port);
    }
    
    /**
     * Disconnect from server and free teoLNullConnectData
     * 
     */
    inline void disconnect() {
        teoLNullDisconnect(con);
    }
    
    
    /**
     * Create initialize L0 client packet
     * 
     * @param host_name Name of this L0 client
     * 
     * @return Length of send data or -1 at error
     */
    inline size_t login(const char* host_name) { 
        
        return teoLNullLogin(con, host_name);
    }   
    
    /**
     * Send command to L0 server
     * 
     * Create L0 clients packet and send it to L0 server
     * 
     * @param cmd Command
     * @param peer_name Peer name to send to
     * @param data Pointer to data
     * @param data_length Length of data
     * 
     * @return Length of send data or -1 at error
     */
    inline ssize_t send(int cmd, 
        const char *peer_name, void *data, size_t data_length) {
        
        return teoLNullSend(con, cmd, peer_name, data, data_length);
    }
    
    /**
     * Send Echo command
     * 
     * @param peer_name
     * @param msg
     * @return 
     */
    inline ssize_t sendEcho(const char *peer_name, const char *msg) {
        return teoLNullSendEcho(con, peer_name, msg);
    }
    
    /**
     * Process echo answer data
     * @return Trip time in ms
     */
    inline int packetEchoAnswerTripTime() {
        return teoLNullProccessEchoAnswer((char*) packetData());
    }
    
    /**
     * Receive packet from L0 server and split or combine it
     * 
     * @return Size of packet or Packet state code
     * @retval >0 Packet received
     * @retval -1 Packet not receiving yet (got part of packet)
     * @retval -2 Wrong packet received (dropped)
     */
    inline ssize_t recv() {
        
        return teoLNullRecv(con);
    }    
    
    /**
     * Sleep
     * 
     * @param ms Time to sleep in ms
     */
    inline void sleep(int ms) {
        teoLNullSleep(ms);
    }
    
    /**
     * Return read buffer of last recv call
     * @return Pointer to teoLNullCPacket
     */
    inline teoLNullCPacket *packet() {
        return (teoLNullCPacket*) con->read_buffer;
    }
    
    /**
     * Return packet arp data of last recv call
     * @return Pointer to ksnet_arp_data_ar
     */
    inline ksnet_arp_data_ar *packetArpData() {
        return (ksnet_arp_data_ar *) (packet()->peer_name + packet()->peer_name_length);
    }
    
    /**
     * Return packet clients array data
     * @return Pointer to teonet_client_data_ar
     */
    inline teonet_client_data_ar *packetClientData() {
        return (teonet_client_data_ar *)
                        (packet()->peer_name + packet()->peer_name_length);
    }
    
    /**
     * Return packet data
     * @return Pointer to void data
     */
    inline void *packetData() {
        return (void*) (packet()->peer_name + packet()->peer_name_length);
    }
};

#endif	/* TEOCLI_CPP_H */
